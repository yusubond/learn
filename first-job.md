## 关于系统设计

> 问：整个系统中数据是如何产生的，又如何被消费？

答：整个系统中的数据是由各异构网络的路由管理服务上报而来，每个异构保证自己网络内部的数据唯一即可，不同的异构网络通过路由类型（前缀）进行区分，从而保证整个系统数据全局唯一。

数据有两部分组成，数据对象和数据版本。同一个数据对象可能被不同的数据版本引用，但是一个数据版本只能唯一确定一个数据对象。

消费数据时，需要先获得所有的数据版本，然后根据数据版本拉取所有的数据对象。



> 问：整个系统中数据的版本是如何管理的？

答：数据版本分两个阶段。

第一个阶段是各异构网络路由管理服务向上游服务上报路由数据时，表征该异构网络数据的不断迭代和更新，采用全量和增量的方式进行上报。

增量保证数据的实时性，全量用来对账，保证数据的最终一致性。

第二阶段是上游服务为每个异构中的数据分配一个唯一的版本号，该唯一的版本号是全局唯一，且每个版本唯一对应一个数据对象。



> 问：整个系统中生产中和消费者是什么样的关系？

答：整个系统中最像生产者的是路由收集服务，这是一个集中式的服务，是数据的源头。

下游服务作为消费者，通过GRPC调用获取全部数据，同时订阅增量事件，消费增量数据。

Pub/Sub功能（means Publish, Subscribe）即发布及订阅功能。

基于事件的系统中，Pub/Sub是目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者(如客户端)以事件订阅的方式订阅一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。

这样的设计主要是为了解除消息发布者和消息订阅者之间的耦合,Redis作为一个pub/sub的server,在订阅者和发布者之间起到了消息路由的功能。



> 问：控制面与转发面如何保证数据的一致性？

答：在虚拟网络中，我们所追求是数据的最终一致性，可通过**定期全量**和**实时增量**的方式来实现。其具体流程为

1）第一次启动，程序构建整个全量，然后推送下发

2）监听增量变化，并对比数据版本，将新数据构造增量，向下推送

3）全量和全量，串行下发



> 整个系统中有哪些好的设计，这样设计的目的是什么？
>
> （或者这个设计解决了什么问题？）

1、主动推送数据，而不是被动拉取

ovs packet in机制是被动触发，往往有首包延迟。主动推送保证数据的即时生效，有数据就转发，没有就不转发。

2、数据分片

数据分片是指转发面数据分片，将一份完整的数据分片至不同的转发设备上。这样设计的目的是单个转发设备的容量有限，为了设备的横向扩容。

3、控制面与转发面sub/pub

这样的设计将 A 和 B 两个服务解耦，B 服务升级，扩容，对 A 几乎没有影响。

4、转发面对账巡检

设计特殊 header 的对账报文，P4 Pipeline查询完后，将修改后的字段存入特殊 header，并将报文返回会源IP地址，校验源收到响应报文后，通过查看修改后的字段，判断转发面表项是否正确。

这样的设计可以适时校验转发面的表项，可提前发现路由表项存在的问题。

5、P4语言中 Mirror 和 Snapshot 发挥了作用

Mirror：将指定规则的报文镜像到其他端口，比如CPU口，方便分析该条流

Snapshot：快照功能，通过设置匹配规则，将抓取该报文在P4 Pipeline整个流水线的处理流程

6、快慢集群的设计

该设计主要是解决数据的可用性问题，因为增量的设计保证数据的实时性，但是如果有一条数据将所有的转发面都写挂掉了，那整个系统都不可用。为了解决这样的问题，设计了快慢集群，快集群的数据实时生效，慢集群的数据延迟生效，这样慢集群所消费的数据永远都是已经被消费过的。

通过设置路由的优先级，快慢切换等，保证流量在正常情况下走快集群，异常情况下走慢集群。慢集群只是丢失了部分增量数据，但整个系统是可用的。

> 整个系统中有没有哪些不好的设计，或者有待商榷的设计?

1、数据源头只有一个

当数据源头被污染，或损害后，所有消费这份数据都会收到影响，也就是控制面数据没有分片。

如果控制面数据分片，那么转发面必须分片，这样的设计就是独立集群。

2、复杂的版本管理

一旦版本错乱，数据将不可信。

这就要代码足够健壮，设计足够清晰，简单，不能出错。

## 关于工作习惯





## 零散但是很好的代码

1、cache的广播机制

cache只负责广播时间，监听者回调。

2、redis db pipeline的运用

3、select case的运用

4、channel的运用

各goroutine负责不同的功能，通过channel传递消息和数据。

